[0m[[0m[0mdebug[0m] [0m[0m> Exec(;Test/compile; collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(Test/compile, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Test / compile[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"6","parents":[]},"eventTime":1687503718394,"message":"Compiling practicing-scala","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Projects/practicing-scala/#practicing-scala/Compile"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"6","parents":[]},"eventTime":1687503718413,"message":"Compiled practicing-scala","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Projects/practicing-scala/#practicing-scala/Compile"},"errors":0,"warnings":0,"time":19}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskStart, {"taskId":{"id":"7","parents":[]},"eventTime":1687503718424,"message":"Compiling practicing-scala-test","dataKind":"compile-task","data":{"target":{"uri":"file:/C:/Projects/practicing-scala/#practicing-scala/Test"}}})[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/taskFinish, {"taskId":{"id":"7","parents":[]},"eventTime":1687503718441,"message":"Compiled practicing-scala-test","status":1,"dataKind":"compile-report","data":{"target":{"uri":"file:/C:/Projects/practicing-scala/#practicing-scala/Test"},"errors":0,"warnings":0,"time":17}})[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 23 Jun, 2023 12:31:58 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Projects\practicing-scala\target\scala-2.12\zinc\inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed 23 Jun, 2023 12:31:58 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/leetcode/src/main/scala/RecentCalls.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L7DefaultArgs.scala","languageId":"scala","version":1,"text":"object L7DefaultArgs extends App{\r\n  \r\n    def trFact(n: Int, acc: Int = 1): Int = // return type is Int \r\n        //default value for acc is 1\r\n        if (n <= 1) acc else trFact(n - 1, n * acc)\r\n\r\n    val fact10 = trFact(10,1) // acc is 1\r\n\r\n    def savePicture(format: String = \"jpg\", width: Int = 1920, height: Int = 1080): Unit = \r\n        println(\"saving picture\")\r\n    savePicture(width = 800, height = 600) // this will use the default value for format\r\n    //mention the parameter name to use the default value for that parameter\r\n\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L7DefaultArgs.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L6CBNvsCBV.scala","languageId":"scala","version":1,"text":"object L6CBNvsCBV extends App {\r\n  \r\n    def calledByValue(x: Long): Unit = {\r\n        println(\"by value: \" + x) // this will print the same value twice\r\n        println(\"by value: \" + x) // because the value of x is passed to the function\r\n    }\r\n\r\n    def calledByName(x: => Long): Unit = {\r\n        println(\"by name: \" + x) // this will print different values\r\n        println(\"by name: \" + x) // because the expression is passed to the function\r\n    }\r\n\r\n    calledByValue(System.nanoTime())\r\n    calledByName(System.nanoTime())\r\n\r\n    def infinite(): Int = 1 + infinite() // this will crash with stackoverflow error\r\n    def printFirst(x: Int, y: => Int) = println(x) // this will not crash\r\n    // because the second parameter is passed by name\r\n    // and it is not evaluated until it is used\r\n    \r\n    // printFirst(infinite(), 34) // this will crash\r\n    printFirst(34, infinite()) // this will not crash \r\n    // because the second parameter is passed by name\r\n    // and it is not evaluated until it is used as lazy evaluation\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L6CBNvsCBV.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L1ValuesVarVal.scala","languageId":"scala","version":1,"text":"\r\nobject ValuesVarVal extends App {\r\n  // VALS IMMUTABLE hote hain\r\n  // COMPILER can infer types\r\n  val x: Int = 42\r\n  println(x)\r\n\r\n  val aString: String = \"hello\"\r\n  //; not zroori\r\n  val anotherString = \"goodbye\"\r\n  val aBoolean: Boolean = false\r\n  val aChar: Char = 'a'\r\n  val anInt: Int = x\r\n  val aShort: Short = 4613\r\n  val aLong: Long = 5273985273895237L\r\n  val aFloat: Float = 2.0f\r\n  val aDouble: Double = 3.14\r\n\r\n  // variables\r\n  var aVariable: Int = 4\r\n\r\n  aVariable = 5 // side effects helps us to see what program is doing\r\n  // var is used for side effects\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L5Objects.scala","languageId":"scala","version":1,"text":"object L5Objects extends App{\r\n  //SCALA DOES NOT HAVE CLASS-LEVEL FUNCTIONALITY (\"static\")\r\n  object Person { //type + its only instance... singleton\r\n    //static/class-level functionality\r\n    val N_EYES = 2 //class level functionality (static)\r\n                   //does not exist in Scala. Object for class level functionality\r\n    def canFly: Boolean = false\r\n    //val var methods can be inside objects\r\n    def apply(mother: Person, father: Person): Person = new Person(\"Bobbie\")\r\n  }\r\n  class Person(val name: String = \"Bobbie\"){\r\n    //instance-level functionality\r\n\r\n  }\r\n\r\n  println(Person.N_EYES)\r\n  println(Person.canFly)\r\n  val mary = new Person\r\n  val john = new Person\r\n  println(mary == john) //false\r\n\r\n  val Person1 = Person //idher we points to the same instance the object singleton\r\n    val Person2 = Person\r\n    println(Person1 == Person2) //true\r\n  val bobbie = Person(mary, john) //factory method from object apply use kra\r\n  val bobbie2 = Person.apply(mary, john) \r\n\r\n  //Scala Applications = Scala object with\r\n  //def main(args: Array[String]): Unit\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L1ValuesVarVal.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L3MethodNotations.scala","languageId":"scala","version":1,"text":"object L3MethodNotations extends App {\r\n  class Person(val name: String, favouriteMovie: String){\r\n    def likes(movie: String): Boolean = movie == favouriteMovie\r\n    def hangOutWith(person: Person): String = s\"${this.name} is hanging out with ${person.name}\"\r\n    //you can even use + operator instead of hangoutwith\r\n    def unary_! : String = s\"$name, what the heck?!\"\r\n    def isAlive: Boolean = true \r\n    def apply(): String = s\"Hi, my name is $name and I like $favouriteMovie\"\r\n  }\r\n\r\n  val mary = new Person(\"Mary\", \"Inception\")\r\n  println(mary.likes(\"Inception\")) // this is a normal method call\r\n  //infix notation = operator notation (syntactic sugar)\r\n  println(mary likes \"Inception\") // this is infix notation\r\n  // infix notation works only with methods which have one parameter\r\n  val tom = new Person(\"Tom\", \"Fight Club\")\r\n  println(mary hangOutWith tom) //result: Mary is hanging out with Tom\r\n  //syntactic sugar works with methods with no parameters also\r\n  //baically beautifying the code\r\n  println(1 + 2)\r\n  println(1.+(2)) // both are same\r\n  // all mathematical operators are methods\r\n  val x = -1 //unary operators are also methods works with - + ~ !\r\n  val y = 1.unary_- //both are same\r\n  println(!mary) // this is a prefix notation (syntactic sugar) for mary.unary_!\r\n  println(mary.unary_!) // both are same\r\n  println(mary.isAlive)\r\n  //println(mary isAlive) // we use postfix notation (syntactic sugar) \r\n                         //for methods with no parameters\r\n  println(mary.apply())\r\n  println(mary()) // both are same\r\n    // when you call an object like a function, it calls the apply method\r\n\r\n\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L7Inheritance2.scala","languageId":"scala","version":1,"text":"object L7Inheritance2 extends App {\r\n    abstract class Animal {\r\n      val creatureType: String\r\n      def eat: Unit\r\n    }\r\n\r\n    class Dog extends Animal {\r\n      val creatureType: String = \"Canine\"\r\n      def eat: Unit = println(\"crunch crunch\") //override keyword is optional\r\n    }\r\n\r\n    //traits\r\n    trait Carnivore {\r\n      def eat(animal: Animal): Unit\r\n      val preferredMeal: String = \"fresh meat\"\r\n      val creatureType: String = \"Test\"\r\n    }\r\n    //traits can be inherited along with class \r\n    //multiple traits can be inherited \r\n    //traits are behavior, abstract class is \"thing\"\r\n    class Crocodile extends Animal with Carnivore {\r\n      //idher ager override keyword nahi lagaya toh error aayega\r\n      //traits can have abstract and non abstract members\r\n      //traits do not have constructor parameters\r\n      //trait me declare kra hua hai creatureType toh override keyword lagana padega\r\n      //same does not goes for abstract class\r\n      override val creatureType: String = \"croc\"\r\n      def eat: Unit = println(\"nomnomnom\")\r\n      def eat(animal: Animal): Unit = println(s\"I'm a croc and I'm eating ${animal.creatureType}\")\r\n    }\r\n\r\n\r\n    val dog = new Dog\r\n    val croc = new Crocodile\r\n    println(croc.creatureType) //croc\r\n    croc.eat(dog) //I'm a croc and I'm eating Canine\r\n    //dog got called and passed as parameter to croc eat method\r\n\r\n    //traits vs abstract classes\r\n    //1 - traits do not have constructor parameters\r\n    //2 - multiple traits may be inherited by the same class\r\n    //3 - traits = behavior, abstract class = \"thing\"\r\n    \r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L13Exceptions.scala","languageId":"scala","version":1,"text":"object L13Exceptions extends App {\r\n  \r\n  //val x: String = null\r\n  //println(x.length) //will crash with a NPE\r\n\r\n  //1. throwing exceptions\r\n  //val aWeirdValue: String = throw new NullPointerException\r\n\r\n  //throwable classes extend the Throwable class\r\n  //Exception and Error are the major Throwable subtypes\r\n\r\n  //2. catching exceptions\r\n  def getInt(withExceptions: Boolean): Int = \r\n    if(withExceptions) throw new RuntimeException(\"No int for you\")\r\n    else 42\r\n\r\n  val potentialFail = try{\r\n    //code that might throw\r\n    getInt(true)\r\n  } catch {\r\n    case e: RuntimeException => println(\"caught a Runtime exception\") //catching\r\n  } finally {\r\n    //code that will get executed NO MATTER WHAT\r\n    //optional\r\n    //does not influence the return type of this expression\r\n    //use finally only for side effects\r\n    println(\"finally\")\r\n  }  \r\n\r\n  println(potentialFail)\r\n\r\n  //3. how to define your own exceptions\r\n  class MyException extends Exception\r\n  val exception = new MyException\r\n\r\n  throw exception //throwing an exception\r\n\r\n  /*\r\n  1. Crash your program with an OutOfMemoryError\r\n  2. Crash with SOError\r\n  3. PocketCalculator\r\n    - add(x,y)\r\n    - subtract(x,y)\r\n    - multiply(x,y)\r\n    - divide(x,y)\r\n    Throw\r\n      - OverflowException if add(x,y) exceeds Int.MAX_VALUE\r\n      - UnderflowException if subtract(x,y) exceeds Int.MIN_VALUE\r\n      - MathCalculationException for division by 0\r\n  */\r\n\r\n  //1. OOM\r\n  //val array = Array.ofDim(Int.MaxValue)\r\n  //ofDim means of dimension and it creates an array of a given dimension\r\n\r\n  //2. SO\r\n  //def infinite: Int = 1 + infinite\r\n  //val noLimit = infinite\r\n\r\n  //3. PocketCalculator\r\n  class OverflowException extends RuntimeException\r\n  class UnderflowException extends RuntimeException\r\n  class MathCalculationException extends RuntimeException(\"Division by 0\")\r\n  \r\n  object PocketCalculator{\r\n    def add(x:Int,y:Int): Int = {\r\n      val result = x + y\r\n      if(x > 0 && y > 0 && result < 0) throw new OverflowException\r\n      else if(x < 0 && y < 0 && result > 0) throw new UnderflowException\r\n      else result\r\n    }\r\n\r\n    def subtract(x:Int,y:Int): Int = {\r\n      val result = x - y\r\n      if(x > 0 && y < 0 && result < 0) throw new OverflowException\r\n      else if(x < 0 && y > 0 && result > 0) throw new UnderflowException\r\n      else result\r\n    }\r\n\r\n    def multiply(x:Int,y:Int): Int = {\r\n      val result = x * y\r\n      if(x > 0 && y > 0 && result < 0) throw new OverflowException\r\n      else if(x < 0 && y < 0 && result < 0) throw new OverflowException\r\n      else if(x > 0 && y < 0 && result > 0) throw new UnderflowException\r\n      else if(x < 0 && y > 0 && result > 0) throw new UnderflowException\r\n      else result\r\n    }\r\n    def divide(x:Int,y:Int): Int = {\r\n      if(y == 0) throw new MathCalculationException\r\n      else x / y\r\n    }\r\n\r\n    println(PocketCalculator.add(Int.MaxValue,10))\r\n    println(PocketCalculator.divide(2,0))\r\n  }\r\n\r\n\r\n\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L12CaseClasses.scala","languageId":"scala","version":1,"text":"object L10CaseClasses {\r\n  /*\r\n    equals, hashCode, toString\r\n   */\r\n  case class Person(name: String, age: Int)\r\n  // 1. class parameters are fields\r\n  val jim = new Person(\"Jim\", 34)\r\n  println(jim.name) // Jim \r\n  //name is a field of the class Person, so we can access it directly now\r\n  // 2. sensible toString\r\n  // println(instance) = println(instance.toString) //syntactic sugar\r\n  println(jim.toString) //Person(Jim,34)\r\n  println(jim) //Person(Jim,34)\r\n\r\n  // 3. equals and hashCode implemented OOTB (out of the box)\r\n  val jim2 = new Person(\"Jim\", 34)\r\n  println(jim == jim2) //true\r\n  //case classes have the equals method implemented OOTB\r\n\r\n  // 4. Case Classes have handy copy method\r\n  val jim3 = jim.copy(age = 45) //copy method is used to create a new instance of the class\r\n  //with the same values as the original instance, except for the values that we pass as parameters\r\n  //in this case, we are creating a new instance of the class Person with the same name as jim\r\n  //but with age = 45\r\n\r\n  // 5. Case Classes have companion objects\r\n  val thePerson = Person //thePerson is a companion object of the class Person \r\n  val mary = Person(\"Mary\", 23) //we can instantiate a case class without using the keyword new\r\n  //this is possible because the compiler will look for a companion object of the class Person\r\n\r\n  // 6. Case Classes are serializable\r\n  //Akka framework uses this feature to serialize messages and send them through the network\r\n\r\n  // 7. Case Classes have extractor patterns = Case Classes can be used in PATTERN MATCHING\r\n\r\n  case object UnitedKingdom {\r\n    def name: String = \"The UK of GB and NI\"\r\n  }\r\n\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L3MethodNotations.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L5Recursion.scala","languageId":"scala","version":1,"text":"import scala.annotation.tailrec\r\nobject L5Recursion extends App{\r\n  \r\n    def factorial(n: Int): Int = \r\n        if(n <=0) 1\r\n        else{\r\n            println(\"Computing factorial of \" +\r\n             n + \" - I first need factorial of \" + (n-1))\r\n             return n*factorial(n-1) // stack frame is created for each recursive call\r\n\r\n        }\r\n    println(factorial(10))\r\n    // println(factorial(5000)) // this will crash with stackoverflow error\r\n\r\n    def anotherFactorial(n: Int): BigInt = {\r\n        @tailrec // this is an annotation to tell the compiler that this is a tail recursive function\r\n        def factHelper(x:Int, accumulator: BigInt): BigInt =  \r\n            if(x <= 1) accumulator\r\n            else factHelper(x-1, x*accumulator) // TAIL RECURSION = use recursive call as the LAST expression\r\n            // this is a TAIL RECURSIVE function as the recursive call is the last expression\r\n            // this will not crash with stackoverflow error\r\n\r\n\r\n        factHelper(n, 1) // this is the first call\r\n        // this is a TAIL RECURSIVE function\r\n        // Goes like this:\r\n        // factHelper(10, 1)\r\n        // factHelper(9, 10*1)\r\n        // factHelper(8, 9*10*1)\r\n    }\r\n\r\n    // when you need loops, use tail recursion\r\n\r\n    // 1) Concatenate a string n times\r\n    def concatenateTailRec(aString: String, n: Int, accumulator: String): String = \r\n        if(n <= 0) accumulator\r\n        else concatenateTailRec(aString, n-1, aString + accumulator)\r\n\r\n    println(concatenateTailRec(\"hello\", 3, \"\")) \r\n\r\n    // 2) IsPrime function tail recursive\r\n    def prime(n:Int): Boolean = {\r\n        @tailrec\r\n        def isPrimeTailRec(t:Int, isStillPrime: Boolean): Boolean =\r\n            if(!isStillPrime) false\r\n            else if(t <=1) true\r\n            else isPrimeTailRec(t-1, n%t != 0 && isStillPrime) \r\n        isPrimeTailRec(n/2, true) // this is the first call\r\n    }\r\n    println(prime(2003))\r\n    println(prime(629))\r\n\r\n    // 3) Fibonacci function, tail recursive\r\n\r\n    def fibonacci(n:Int): Int={\r\n        @tailrec\r\n        def fiboTailRec(i:Int, last: Int, nextToLast: Int): Int = \r\n            if(i >= n) last // this is the last call\r\n            else fiboTailRec(i+1, last + nextToLast, last) // TAIL RECURSION\r\n        if(n <= 2) 1 // this is the first call\r\n        else fiboTailRec(2, 1, 1) // this is the first call\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L8InheritanceExercise.scala","languageId":"scala","version":1,"text":"\r\n\r\nabstract class MyList {\r\n  /*\r\n    head = first element of the list\r\n    tail = remainder of the list\r\n    isEmpty = is this list empty\r\n    add(int) => new list with this element added\r\n    toString => a string representation of the list\r\n  */\r\n  def head: Int \r\n  def tail: MyList \r\n  def isEmpty: Boolean\r\n  def add(element: Int): MyList\r\n  def printElements: String //polymorphic call\r\n                            //here we would need to override this method in the child class\r\n                            //verna missing implementation\r\n  override def toString: String = \"[\" + printElements + \"]\"\r\n}\r\n\r\nobject Empty extends MyList {\r\n  def head = throw new NoSuchElementException\r\n  def tail = throw new NoSuchElementException\r\n  def isEmpty = true\r\n  def add(element: Int): MyList = new Cons(element, Empty)\r\n  def printElements: String = \"\"\r\n}\r\n\r\nclass Cons(h: Int, t: MyList) extends MyList {\r\n  def head: Int = h\r\n  def tail: MyList = t\r\n  def isEmpty: Boolean = false\r\n  def add(element: Int): MyList = new Cons(element, this) //Cons hii return horha\r\n  def printElements: String = \r\n    if(t.isEmpty) \"\" + h\r\n    else h + \" \" + t.printElements //recursive call\r\n}\r\n\r\nobject ListTest extends App {\r\n  val list = new Cons(1, Empty)\r\n  println(list.head)\r\n  val list2 = new Cons(1, new Cons(2, new Cons(3, Empty)))\r\n  println(list2.tail.head)\r\n  println(list2.add(4).head) //add method returns a new list with the element added \r\n  // println(list2.printElements)\r\n  println(list2.toString) //will call toString method of the object\r\n                          //that will call printElements method of the object\r\n  //println(list2) //syntactic sugar for println(list2.toString) as toString is a method of the object\r\n  //plymorphic call where the most derived method will be called at runtime\r\n\r\n\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didClose: JsonRpcNotificationMessage(2.0, textDocument/didClose, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Scala%20Basics%20%5B2%5D/L5Recursion.scala"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Projects/practicing-scala/DanielScala/src/main/scala/Oops%20%5B3%5D/L1Basics.scala","languageId":"scala","version":1,"text":"object L1Basics extends App {\r\n   val person = new Person(\"John\", 26)\r\n   val person1 = new Person1(\"Sam\",56)\r\n   println(person) // Result: Person@1b6d3586\r\n    // this is a class instance\r\n    println(person1.age) // Result: 0\r\n    //println(person.age) class parameters are not fields\r\n    person1.greet(\"Daniel\")\r\n    person1.greet()\r\n}\r\nclass Person(name: String, age: Int) // this is a constructor which goes inside\r\nclass Person1(name: String, val age: Int){\r\n    //body\r\n    val x = 2 // this is a field\r\n    println(1 + 3) // this is a side effect\r\n    //side effect is an expression which returns unit\r\n    //unit is a type which has only one value which is ()\r\n    def greet(name: String): Unit = println(s\"${this.name} says: Hi, $name\")\r\n    //this is a method which returns unit which is a side effect\r\n    def greet(): Unit = println(s\"Hi, I am $name\") \r\n    //isme name humesahe hii Sam rhega\r\n} //val makes age a field"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled request received: shutdown: JsonRpcRequestMessage(2.0, â™¨1, shutdown, null})[0m
